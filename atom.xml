<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Written by Thorsten Ball]]></title>
  <link href="http://mrnugget.github.com/atom.xml" rel="self"/>
  <link href="http://mrnugget.github.com/"/>
  <updated>2012-07-10T11:36:45+02:00</updated>
  <id>http://mrnugget.github.com/</id>
  <author>
    <name><![CDATA[Thorsten Ball]]></name>
    <email><![CDATA[mrnugget@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vim Learning Resources]]></title>
    <link href="http://mrnugget.github.com/blog/2012/07/09/vim-learning-resources/"/>
    <updated>2012-07-09T11:35:00+02:00</updated>
    <id>http://mrnugget.github.com/blog/2012/07/09/vim-learning-resources</id>
    <content type="html"><![CDATA[<p>I&#8217;ve been a Vim user for a long time but only in the last year I actually
started to really use it. No, I don&#8217;t mean to say that I spend years of my
life with an opened editor on my workspace and just stared at it. What I really
mean is that those early years of my Vim usage and knowledge mostly consisted
of <em>h, j, k, l</em>, <em>:wq</em> and <em>:%s/replace/this/g</em>. That and syntax highlighting was
pretty much Vim for me.</p>

<p>One of the things that makes Vim so great for me is that it doesn&#8217;t force you to
use or understand something. I was able to get work done with just the basic
knowledge I had. But then came that moment when I stumbled upon a
blog post about Vim&#8217;s text objects and my jar dropped on my keyboard: <em>&#8220;So
that&#8217;s how it works?!&#8221;</em></p>

<p>Vim has a steep learning curve and there are bumps on the road where you can get
stuck. And I know a lot of people do get stuck. You may like it there, being
stuck, but keep in mind: sometimes it&#8217;s just a little tip that can get you
forward. A small push that gives you an <em>AHA!</em> moment. Thankfully there are a
lot of these available everywhere, though sometimes they are not that
easy to find, which is the reason I&#8217;m writing this post.</p>

<p>The following is a list consisting of screencasts, video tutorials, blog posts,
tips and tricks concerning Vim and how to master it. The items on the list are
the ones that got me forward when I was stuck on my way to Vim wizardry (mind
you, I&#8217;m not there yet, not even close but I&#8217;m wearing the nice hat anyway). I
bet someone can find some use in this.</p>

<!-- more -->


<h2>Video Tutorials</h2>

<p><a href="http://www.vimcasts.org" title="Vimcasts.org">vimcasts.org</a>:
Everybody who&#8217;s starting to use Vim nowadays knows about this site and rightfully so.
Vimcasts is a great resource when learning Vim. <a href="http://drewneil.com" title="Drew Neil">Drew Neil</a>
teaches you Vim in 35 screencasts of top notch quality. Also, I
hear his <a href="http://pragprog.com/book/dnvim/practical-vim" title="Practical Vim">book</a> is
great too, as are his <a href="http://lanyrd.com/profile/nelstrom/sessions/" title="Vimcasts workshops">workshops</a>.</p>

<p><a href="http://http://www.derekwyatt.org/vim/vim-tutorial-videos/" title="Derek Wyatt's Vim Tutorial Videos">Derek Wyatt&#8217;s Vim videos</a>:
Bookmark this, now! I mean it! This collection of video tutorials is one of the
most hidden gems in the Vim galaxy and I don&#8217;t know why. Derek Wyatt has an
immense knowledge of Vim, his videos are fun to watch and packed with Vim
knowledge, explaining topics interesting to beginners and experts alike. Watch
them!</p>

<p><a href="https://peepcode.com/products/smash-into-vim-i" title="Smash Into Vim">PeepCode - Smash Into Vim</a>:
PeepCode is known for excellent screencasts and the two videos about Vim are no
exception to the rule. If you want to invest some money in your mastery of Vim:
this is the way to go.</p>

<h2>Blog Posts</h2>

<p><a href="http://stevelosh.com/blog/2010/09/coming-home-to-vim/" title="Steve Losh - Coming Home To Vim">Coming Home To Vim</a>:
This post by Steve Losh pops up on Hacker News from time to time and always gets
lots of positive feedback. It&#8217;s one of those posts that made me &#8216;get&#8217;
what text objects are and what &#8216;speaking to the editor&#8217; is all about. Totally
worth the read, especially if you have the same background as Steve, coming from
a different editor but determined to dig into Vim.</p>

<p><a href="http://mislav.uniqpath.com/2011/12/vim-revisited/" title="Mislav Marohnić - Vim: revisited">Vim: revisited</a>:
In this post called <em>Vim: revisited</em> Mislav explains how and why he finally
&#8220;got&#8221; Vim, how his approach to text editing changed through Vim and what to keep
in mind when trying to do the same thing as he did. The &#8216;Essential
plugins&#8217; section at the end is a good starting point of you feel you&#8217;re missing
out on some features when using Vim.</p>

<p><a href="http://www.viemu.com/a-why-vi-vim.html" title="Why, oh WHY, do those #?@! nutheads use vi?">Why, oh WHY, do those #?@! nutheads use vi?</a>:
&#8220;Learning an editor, master it, put work into it — are you crazy? Why would
someone do that? We&#8217;re talking about a <em>text editor</em>, for god&#8217;s sake!&#8221; Well,
read this post, learn the answers to your questions and gain some knowledge
concerning vi and Vim.</p>

<p><a href="http://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/" title="Vim Text Objects: The Definitive Guide">Vim Text Objects: The Definitive Guide</a>:
If you have used <em>ciw</em>, <em>di&#8221;</em>, <em>dat</em> in Vim before but never really found out
what those commands mean and how someone can actually memorize them: read this
post by Jared Carroll on Vim&#8217;s text objects.</p>

<h2>Stack Overflow</h2>

<p>Another way of getting a great insight into the usage of Vim is by reading
through the <a href="http://stackoverflow.com/questions/tagged/vim?sort=votes&amp;pagesize=15" title="Most upvoted Vim questions">most upvoted answers tagged with &#8216;Vim&#8217;</a>
on stackoverflow. The questions themselves might not sound interesting to you at
first sight, but digging the answers is worth it most of the time. Check out the
top two of those questions and read the first answers to get a taste of what&#8217;s
waiting for you:</p>

<p><a href="http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim" title="Stack Overflow - What is your most productive shortcut with Vim?">What is your most productive shortcut with Vim?</a>:
The first answer to this question is something you should keep in your bookmarks
toolbar: lots and lots of information about Vim and the editing philosophy
behind it. Also: further down on the page are cool mini-screencast-gifs.</p>

<p><a href="http://stackoverflow.com/questions/235839/how-do-i-indent-multiple-lines-quickly-in-vi" title="How do I indent multiple lines quickly in vi?">How do I indent multiple lines quickly in vi?</a>:
Check out the second answer to this question as it demonstrates in a fascinating
way how flexible Vim is when it comes to solving problems.</p>

<h2>Vim Tips</h2>

<p><a href="http://vim.wikia.com/wiki/Vim_Tips_Wiki" title="Vim Tips Wiki">Vim Tips Wiki</a>:
This is one of the all time greats. What was formerly known as the &#8216;Tips&#8217; section
on <a href="http://www.vim.org" title="Vim.org">vim.org</a> is now a wiki. That means there are
thousands of tips concerning Vim, vimrc files, plugins and everything else
connected with Vim in any way <em>plus</em> comments and updates.</p>

<p><a href="http://www.rayninfo.co.uk/vimtips.html" title="Best of Vim Tips">Best of Vim Tips</a>:
This might not be the prettiest of all websites, but if you keep digging through
this one you might find one or two treasures waiting for you. This was
one of the most upvoted tips in the old Vim.org tips section. Probably because
it contains the knowledge of five hundred tips combined.</p>

<h2>Tools &amp; Tutorials</h2>

<p><a href="http://bytefluent.com/vivify/" title="Vivify">Vivify</a>: Vim looks ugly? Well, it
shouldn&#8217;t. Check out Vivify. This site lets you preview thousands of Vim
colorschemes without the need to download.</p>

<p><a href="http://michael.peopleofhonoronly.com/vim/" title="Vim Cheatsheet for Programmers">Vim Cheatsheet for Programmers</a>:
There are a lot of Vim cheatsheets floating around
on the web and I don&#8217;t know if there is another one better than this one. All I
know is that this one was pinned to the wall next to my screen for years.</p>

<p><a href="http://vim.runpaint.org/toc/" title="Vim Recipes">Vim Recipes</a>: A huge collection of
Vim recipes ranging from &#8216;Quitting Vim&#8217; to &#8216;Extending Vim with Scripts and
Plugins&#8217;. Always worth a visit.</p>

<h2>Help Yourself!</h2>

<p>Open Vim and type in <em>:help</em>. This may be the most important command in Vim
you&#8217;ll come across, it certainly is the most helpful. Especially when looking
for specific information: e.g. <em>:help global</em>. And if you&#8217;re just starting out
and don&#8217;t know how to type in commands into Vim you should type this command
into your shell: <em>vimtutor</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How I used 98840 commands less and saved 4 seconds]]></title>
    <link href="http://mrnugget.github.com/blog/2012/06/20/how-i-used-98840-commands-less-and-saved-4-seconds/"/>
    <updated>2012-06-20T18:58:00+02:00</updated>
    <id>http://mrnugget.github.com/blog/2012/06/20/how-i-used-98840-commands-less-and-saved-4-seconds</id>
    <content type="html"><![CDATA[<p>In my last post I explained how to implement a search autocompletion backend
using Redis. This week I used the described implementation with its <code>add_movie</code> method to put thousands of movies into my Redis database
in order to use them for the autocompletion on
<a href="http://anygood.heroku.com" title="AnyGood - Check if a movie was
any good!">anygood.heroku.com</a>. It&#8217;s the same method as described in the last post, but with
important change I didn&#8217;t think about too much: I did not overwrite the score of the members in the sorted
sets. The method I used for adding movies looked like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">add_movie</span><span class="p">(</span><span class="n">movie_hash</span><span class="p">)</span>
</span><span class='line'>  <span class="n">prefixes</span>    <span class="o">=</span> <span class="n">prefixes_for</span><span class="p">(</span><span class="n">movie_hash</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>  <span class="n">hashed_name</span> <span class="o">=</span> <span class="n">data_hash_key_for</span><span class="p">(</span><span class="n">movie_hash</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">prefixes</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">prefix</span><span class="o">|</span>
</span><span class='line'>    <span class="n">score</span> <span class="o">=</span> <span class="no">REDIS</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="n">index_key_for</span><span class="p">(</span><span class="n">prefix</span><span class="p">),</span> <span class="n">hashed_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_i</span> <span class="o">||</span> <span class="mi">0</span>
</span><span class='line'>    <span class="no">REDIS</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="n">index_key_for</span><span class="p">(</span><span class="n">prefix</span><span class="p">),</span> <span class="n">score</span><span class="p">,</span> <span class="n">hashed_name</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="no">REDIS</span><span class="o">.</span><span class="n">hset</span><span class="p">(</span><span class="n">data_key</span><span class="p">,</span> <span class="n">hashed_name</span><span class="p">,</span> <span class="n">movie_hash</span><span class="o">.</span><span class="n">to_json</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Adding movies took suspiciously long, longer than I thought it would.
Looking at it now it&#8217;s pretty easy to tell why: it was exactly that small change
that lowered the speed of my importing process, I <em>did</em> cache the member score
in <em>every</em> prefix set and then used in the <code>REDIS.zadd</code> line. Every time a movie
was added, for each of its prefixes the score of the correspondent sorted set
member was saved and used again. That&#8217;s not bad at all, no, it didn&#8217;t slip in
there either! Heck, I wrote tests for this. But looking at the code I concluded
that it was not a feature I needed. Using the code above, every movie would have
a different rank in the autocomplete output according to the user input. One
movie could be ranked higher when the user typed in <em>the</em> and ranked lower when
the input was <em>dark</em>. That is pretty cool, but I wanted a different behaviour:
the sorted set members associated with one movie should have one score, the same
one in every set. And after running some benchmarks I found out how implementing
the wrong behaviour slowed me down.</p>

<!-- more -->


<p>Testing this was simple: I wrote a small script that allowed me to add ten
thousand movies with the aforementioned method. The rest is just a shell and
<code>time</code>. The script looks like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#!/usr/bin/env ruby -wKU</span>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;redis&#39;</span>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;digest&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="no">REDIS</span> <span class="o">=</span> <span class="no">Redis</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># We need to generate the prefixes for every moviename</span>
</span><span class='line'><span class="k">def</span> <span class="nf">prefixes_for</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span><span class='line'>  <span class="n">prefixes</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'>  <span class="n">words</span>    <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">downcase</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">words</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">word</span><span class="o">|</span>
</span><span class='line'>    <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.word</span><span class="o">.</span><span class="n">length</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">prefixes</span> <span class="o">&lt;&lt;</span> <span class="n">word</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">i</span><span class="o">]</span> <span class="k">unless</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">prefixes</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Adding 10000 movies</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10000</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
</span><span class='line'>  <span class="n">movie_name</span>  <span class="o">=</span> <span class="s2">&quot;The Number</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="n">hashed_name</span> <span class="o">=</span> <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="n">movie_name</span><span class="p">)</span>
</span><span class='line'>  <span class="n">prefixes</span>    <span class="o">=</span> <span class="n">prefixes_for</span><span class="p">(</span><span class="n">movie_name</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">prefixes</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">prefix</span><span class="o">|</span>
</span><span class='line'>    <span class="n">score</span> <span class="o">=</span> <span class="no">REDIS</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="s2">&quot;testing:redis:index:</span><span class="si">#{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">movie_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_i</span> <span class="o">||</span> <span class="mi">0</span>
</span><span class='line'>    <span class="no">REDIS</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="s2">&quot;testing:redis:index:</span><span class="si">#{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">movie_name</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="no">REDIS</span><span class="o">.</span><span class="n">hset</span><span class="p">(</span><span class="s2">&quot;testing:redis:data:Number</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">movie_name</span><span class="p">,</span> <span class="s2">&quot;This is Number </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>It&#8217;s a good idea to delete all keys in our instance (using <code>FLUSHALL</code>) before
running this script and monitoring is especially and always great: Redis&#8217; handy
<code>MONITOR</code> command outputs all the commands our instance receives, complete
with timestamp. So, monitoring our instance in the background, its time to see
how often <code>ZSCORE</code> gets called when we add those ten thousand movies:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>redis-cli FLUSHALL
</span><span class='line'>OK
</span><span class='line'><span class="nv">$ </span>redis-cli MONITOR | grep zscore &gt; zscore_for_every_prefix.txt &amp;
</span><span class='line'><span class="o">[</span>1<span class="o">]</span> 94937 94938
</span><span class='line'><span class="nv">$ </span>ruby insert_10000_movies.rb
</span><span class='line'><span class="nv">$ </span><span class="nb">fg</span>
</span><span class='line'><span class="o">[</span>1<span class="o">]</span>  + 94937 running    redis-cli MONITOR |
</span><span class='line'>       94938 running    grep zscore &gt; zscore_for_every_prefix.txt
</span><span class='line'>^C
</span><span class='line'><span class="nv">$ </span>wc -l zscore_for_every_prefix.txt
</span><span class='line'>  108840 zscore_for_every_prefix.txt
</span></code></pre></td></tr></table></div></figure>


<h2>Use less commands!</h2>

<p>That is a huge number. But don&#8217;t you worry, lowering it is pretty easy. Just
change a couple of lines of <code>insert_10000_movies.rb</code> to get the behaviour we
want and it looks like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># [...]</span>
</span><span class='line'><span class="n">score</span> <span class="o">=</span> <span class="no">REDIS</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="s2">&quot;testing:redis:index:</span><span class="si">#{</span><span class="n">prefixes</span><span class="o">.</span><span class="n">first</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">movie_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_i</span> <span class="o">||</span> <span class="mi">0</span>
</span><span class='line'><span class="n">prefixes</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">prefix</span><span class="o">|</span>
</span><span class='line'>  <span class="no">REDIS</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="s2">&quot;testing:redis:index:</span><span class="si">#{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">movie_name</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="c1"># [...]</span>
</span></code></pre></td></tr></table></div></figure>


<p>With this in place, <code>ZSCORE</code> will get called exactly one time for each movie and
not for every prefix of every movie. Instead of using <code>ZSCORE</code> 108840 times,
after that small change it only gets called ten thousand times.  And 108840
minus 10000 is <em>98840</em>. That&#8217;s <em>98840 commands</em> less!</p>

<p>But let&#8217;s not stop here. On my MacBook Air it took roughly <em>7</em> seconds to insert
those ten thousand movies using <code>ZSCORE</code> on every prefix. With <em>98840</em>
commands less it only takes around <em>4</em>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>redis-cli FLUSHALL
</span><span class='line'>OK
</span><span class='line'><span class="nv">$ </span><span class="nb">time </span>ruby insert_10000_movies.rb
</span><span class='line'>ruby insert_10000_movies.rb  7.39s user 3.78s system 54% cpu 20.448 total
</span><span class='line'><span class="nv">$ </span>redis-cli FLUSHALL
</span><span class='line'>OK
</span><span class='line'><span class="nv">$ </span><span class="nb">time </span>ruby insert_10000_with_one_prefix_score.rb
</span><span class='line'>ruby insert_10000_movies_with_one_prefix.rb  4.42s user 2.19s system 54% cpu 12.112 total
</span></code></pre></td></tr></table></div></figure>


<h2>Redis and the Pipeline</h2>

<p>I wasn&#8217;t satisfied with this result and while examining the code again I
remembered <a href="http://www.redis.io/topics/pipelining" title="Redis pipelining documentation">Redis pipelining abilities.</a></p>

<p>When sending requests to Redis using pipelining the server doesn&#8217;t wait
for the client (our code) to progress its responses, it just accepts them and
does as it&#8217;s told. And the client doesn&#8217;t read any responses, it just fires
the next request until all commands in the pipeline are sent.
<a href="https://github.com/redis/redis-rb" title="redis-rb">redis-rb</a> fully supports
pipelining to Redis and using it is pretty straightforward: Just put the part of your code
that&#8217;s sending requests to Redis into a <code>REDIS.pipelined</code> block and everything
in the block will be going through the pipeline. That should save us some
seconds, right? Time to make a use of it:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># [...]</span>
</span><span class='line'><span class="n">score</span> <span class="o">=</span> <span class="no">REDIS</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="s2">&quot;testing:redis:index:</span><span class="si">#{</span><span class="n">prefixes</span><span class="o">.</span><span class="n">first</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">movie_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_i</span> <span class="o">||</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="no">REDIS</span><span class="o">.</span><span class="n">pipelined</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">prefixes</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">prefix</span><span class="o">|</span>
</span><span class='line'>    <span class="no">REDIS</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="s2">&quot;testing:redis:index:</span><span class="si">#{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">movie_name</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="no">REDIS</span><span class="o">.</span><span class="n">hset</span><span class="p">(</span><span class="s2">&quot;testing:redis:data:Number</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">movie_name</span><span class="p">,</span> <span class="s2">&quot;This is Number </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="c1"># [...]</span>
</span></code></pre></td></tr></table></div></figure>


<p>What we&#8217;re doing here is precisely what I just described: for each movie we open
a pipeline to Redis and send all the <code>ZADD</code> and finally the <code>HSET</code> command
straight to Redis without blinking an eye. The response won&#8217;t get processed
until the block is finished. Doing that our script runs noticeably
faster. But since we all love benchmarking, hard numbers and speed, let&#8217;s see
how fast exactly:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>redis-cli FLUSHALL
</span><span class='line'>OK
</span><span class='line'><span class="nv">$ </span><span class="nb">time </span>ruby insert_10000_movies_pipelined.rb
</span><span class='line'>ruby insert_10000_movies_optimized.rb  3.42s user 1.26s system 86% cpu 5.414 total
</span></code></pre></td></tr></table></div></figure>


<p><em>4</em> seconds less! That is more than 50% faster! Wow! This is great, this is
magnificient! Let&#8217;s pipeline all the commands!</p>

<h2>Not so fast, buddy!</h2>

<p>Woah, easy, buddy, hold it right there! Let me tell you something: It would be
great if we could put all our Redis interactions within a <code>REDIS.pipeline</code>
block, but there is one small problem. As I said, the server doesn&#8217;t wait for
the client to process its responses and the client waits until the pipeline is
empty. That means you can&#8217;t pipeline blocks of code in which you work
with the servers response. The code at the beginning of this article did use
the server&#8217;s responses, remember? We used <code>ZSCORE</code> for every prefix to get the score
of the member in that particular set, saved it and then updated the member of the
set with exactly that score. That&#8217;s not possible when sending our orders through
the pipeline.</p>

<p>I guess an example should clear things up so let&#8217;s add a couple of movies with
the following code, resulting in every member of every index set having a score
of 10:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">REDIS</span><span class="o">.</span><span class="n">pipelined</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">prefixes</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">prefix</span><span class="o">|</span>
</span><span class='line'>    <span class="no">REDIS</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="s2">&quot;testing:redis:index:</span><span class="si">#{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">movie_name</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Using <code>redis-cli MONITOR</code> in a parallel shell session, we can see what&#8217;s being
sent to Redis:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[.</span><span class="n">.</span><span class="o">.]</span>
</span><span class='line'><span class="mi">1341173848</span><span class="o">.</span><span class="mi">796741</span> <span class="s2">&quot;zadd&quot;</span> <span class="s2">&quot;testing:redis:index:number1000&quot;</span> <span class="s2">&quot;10&quot;</span> <span class="s2">&quot;The Number10000&quot;</span>
</span><span class='line'><span class="mi">1341173848</span><span class="o">.</span><span class="mi">796772</span> <span class="s2">&quot;zadd&quot;</span> <span class="s2">&quot;testing:redis:index:number10000&quot;</span> <span class="s2">&quot;10&quot;</span> <span class="s2">&quot;The Number10000&quot;</span>
</span><span class='line'><span class="mi">1341173848</span><span class="o">.</span><span class="mi">796923</span> <span class="s2">&quot;hset&quot;</span> <span class="s2">&quot;testing:redis:data:Number10000&quot;</span> <span class="s2">&quot;The Number10000&quot;</span> <span class="s2">&quot;This is Number 10000&quot;</span>
</span><span class='line'><span class="o">[.</span><span class="n">.</span><span class="o">.]</span>
</span></code></pre></td></tr></table></div></figure>


<p>That looks fine. Now, if we were to add those movies again (with the keys still in our Redis
instance), and try to cache the scores inside a <code>pipeline</code> block, it won&#8217;t
work, since the client doesn&#8217;t process the servers response until after the
pipelining block is finished. The following change in the code will show when
the response is there and when it isn&#8217;t:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">scores</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="n">scores</span> <span class="o">&lt;&lt;</span> <span class="no">REDIS</span><span class="o">.</span><span class="n">pipelined</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">prefixes</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">prefix</span><span class="o">|</span>
</span><span class='line'>    <span class="n">scores</span> <span class="o">&lt;&lt;</span> <span class="no">REDIS</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="s2">&quot;testing:redis:index:</span><span class="si">#{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">movie_name</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="n">scores</span><span class="o">.</span><span class="n">inspect</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>This will output the following for each movie:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="kp">nil</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">[</span><span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="o">]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>The servers responses are only there (the last element in the <code>scores</code> array)
after the block is finished, inside the block the <code>scores</code> array is filled with
<code>nil</code>s: no response has been read yet. Using nearly the same code but
<em>without pipelining</em> we get totally different results:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">scores</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="n">prefixes</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">prefix</span><span class="o">|</span>
</span><span class='line'>  <span class="n">scores</span> <span class="o">&lt;&lt;</span> <span class="no">REDIS</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="s2">&quot;testing:redis:index:</span><span class="si">#{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">movie_name</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">scores</span><span class="o">.</span><span class="n">inspect</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">scores</span><span class="o">.</span><span class="n">inspect</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s2">&quot;10&quot;</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can see now that pipelining is a great way to gain speed when progressing huge lists
of commands, which is exactly what I was after when adding thousands and
thousands of movies, but when you need to work with the servers response, say
when getting a value and using that value in another request, the value just
won&#8217;t be there inside a pipelining block, only after it finished executing.
Pipelining is a great thing to know, but only when the requirements are right
and it&#8217;s applicable.</p>

<p>That means I used 98840 commands less by adjusting the code for its use case and
saved 4 seconds using the right tool for the job, which is always great, isn&#8217;t
it?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ordered Search Autocompletion With Redis]]></title>
    <link href="http://mrnugget.github.com/blog/2012/06/08/search-autocompletion-with-redis/"/>
    <updated>2012-06-08T16:42:00+02:00</updated>
    <id>http://mrnugget.github.com/blog/2012/06/08/search-autocompletion-with-redis</id>
    <content type="html"><![CDATA[<p>I spent the last weekend building a caching system for <a href="http://anygood.heroku.com" title="Any Good">AnyGood</a>
using <a href="http://www.redis.io" title="Redis">Redis</a> to save API responses for certain
amount of time. Since the next item on my TODO list was autocompletion for my search
form I started googling around looking for solutions involving Redis and I
stumbled about two great posts examining this particular topic. The <a href="http://antirez.com/post/autocomplete-with-redis.html" title="Autocomplete with Redis">first one</a>
written by Salvatore Sanfilippo is a great explanation on how to use
Redis for autocompletion and goes in great detail when explainin the algorithm.
And the <a href="http://patshaughnessy.net/2011/11/29/two-ways-of-using-redis-to-build-a-nosql-autocomplete-search-index" title="Two ways of using Redis to build a NoSQL autocomplete search index">second one</a>
by Pat Shaughnessy is a great help when explaining Sanfilippos algorithm and comparing
it to <a href="https://github.com/seatgeek/soulmate" title="Soulmate">Soulmate</a>, &#8220;a tool to
help solve the common problem of developing a fast autocomplete feature. It uses
Redis&#8217;s sorted sets to build an index of partially completed words and the
corresponding top matching items, and provides a simple sinatra app to query
them.&#8221;</p>

<p>So I spent a good amount of time studying those articles and reading through the
source code of Soulmate before I decided to write my own solution. Why? Because
it was a rainy sunday afternoon, playing around with Redis is fun and I wanted
to learn more about it. And after all, I wanted support for multiple phrases,
search result ordering and Soulmate did all that and a bit more and just setting
it up wouldn&#8217;t have the same learning effect. And since I was out to play, I
might as well have fun. So let&#8217;s see how to this&#8230;</p>

<!-- more -->


<h2>What it should do</h2>

<p>Let&#8217;s suppose we want autocompletion for our search form that not only returns a
single value for each proposed item but also comes with some data that we can
present. Also, let&#8217;s go one step further and say that the search form
should present the items available to the user in an ordered way, e.g. by
popularity.</p>

<p>So when a user types into the search form, we want to to show him all the
possible movies matching his search phrases. That means the first thing we&#8217;ve
got to do is dump this data in to Redis. Like Soulmate, we use a <a href="http://redis.io/topics/data-types#hashes" title="Redis Hashes">Redis hash</a>
here, where each movie has its own unique key. This key can be anything as long
as it&#8217;s unique. I&#8217;m using MD5 in Anygood, since I don&#8217;t save movies into a
database and they don&#8217;t have a unique ID this context. But let&#8217;s suppose we do
have an unique ID, dumping the data into Redis is pretty simple:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HSET moviesearch:data 1 "{\"name\":\"Kill Bill\",\"year\":2003}"
</span><span class='line'>HSET moviesearch:data 2 "{\"name\":\"King Kong\",\"year\":2005}"
</span><span class='line'>HSET moviesearch:data 3 "{\"name\":\"Killer Elite\",\"year\":2011}"
</span><span class='line'>HSET moviesearch:data 4 "{\"name\":\"Kill Bill 2\",\"year\":2004}"
</span><span class='line'>HSET moviesearch:data 5 "{\"name\":\"Kilts for Bill\",\"year\":2027}"
</span><span class='line'>HSET moviesearch:data 6 "{\"name\":\"Kids\",\"year\":1995}"
</span><span class='line'>HSET moviesearch:data 7 "{\"name\":\"Kindergarten Cop\",\"year\":1990}"
</span><span class='line'>HSET moviesearch:data 8 "{\"name\":\"The Green Mile\",\"year\":1999}"
</span><span class='line'>HSET moviesearch:data 9 "{\"name\":\"The Dark Knight\",\"year\":2008}"
</span><span class='line'>HSET moviesearch:data 10 "{\"name\":\"The Dark Knight Rises\",\"year\":2012}"</span></code></pre></td></tr></table></div></figure>


<p><code>HSET</code> is the Redis command so save something into an hash. The key for this
hash is <code>moviesearch:data</code>. The single keys for every movie in this hash are the
unique IDs: <em>1, 2, 3, &#8230;</em>. And the data we&#8217;re saving are JSON strings, which
are a pretty convenient way of saving objects in Redis. Also, it&#8217;s easy enough
in Ruby to convert a Ruby hash to JSON and after retrieving it from Redis back
to a hash:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;json&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Before dumping to Redis:</span>
</span><span class='line'><span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="s1">&#39;Kill Bill&#39;</span><span class="p">,</span> <span class="n">year</span><span class="p">:</span> <span class="mi">2003</span><span class="p">}</span><span class="o">.</span><span class="n">to_json</span>
</span><span class='line'><span class="c1"># =&gt; &quot;{\&quot;name\&quot;:\&quot;Kill Bill\&quot;,\&quot;year\&quot;:2003}&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># After retrieving from Redis:</span>
</span><span class='line'><span class="no">JSON</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;{</span><span class="se">\&quot;</span><span class="s2">name</span><span class="se">\&quot;</span><span class="s2">:</span><span class="se">\&quot;</span><span class="s2">Kill Bill</span><span class="se">\&quot;</span><span class="s2">,</span><span class="se">\&quot;</span><span class="s2">year</span><span class="se">\&quot;</span><span class="s2">:2003}&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; {&quot;name&quot;=&gt;&quot;Kill Bill&quot;, &quot;year&quot;=&gt;2003}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Oh and btw. I&#8217;m using <a href="https://github.com/redis/redis-rb" title="redis-rb">redis-rb</a>
as the Ruby client to connect to Redis, which does not only support Redis
transactions and pipelining, but the best thing about this client is that the
<a href="http://www.redis.io/commands" title="Redis commands">Redis commands</a> have the same
name and take the same arguments (well, most of the time), which is especially
great when getting to know Redis and looking up commands in the documentation.
So now we&#8217;ve got the movies in Redis, how do we find them again?</p>

<h2>Prefixes everywhere!</h2>

<p>People are most likely trying to search for a movie by starting to type its name
into the input field. And we want to present them the right movies before
they&#8217;re even finished typing the whole name, right? That&#8217;s why we&#8217;re talking
about autocompletion here. That means we need an association between word
prefixes and the movies. If someone where to type in <em>The Dar</em> we want to
show <em>The Dark Knight</em> and <em>The Dark Knight Rises</em> as possible search terms.
Long story short: we need to get the prefixes of every movie we just dumped in our
<code>moviesearch:data</code> hash. For that I&#8217;m using a simple method, which is heavily based
on the one Sanfilippo uses in his example script:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">prefixes_for</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span><span class='line'>  <span class="n">prefixes</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'>  <span class="n">words</span>    <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">downcase</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">words</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">word</span><span class="o">|</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.word</span><span class="o">.</span><span class="n">length</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">prefixes</span> <span class="o">&lt;&lt;</span> <span class="n">word</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">i</span><span class="o">]</span> <span class="k">unless</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">prefixes</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The movie with the name <em>The Dark Knight</em> will result in the following prefixes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">prefixes_for</span><span class="p">(</span><span class="s1">&#39;The Dark Knight&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; [&quot;th&quot;, &quot;the&quot;, &quot;da&quot;, &quot;dar&quot;, &quot;dark&quot;, &quot;kn&quot;, &quot;kni&quot;, &quot;knig&quot;, &quot;knigh&quot;, &quot;knight&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And <em>The Dark Knight Rises</em> will result in the following prefixes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">prefixes_for</span><span class="p">(</span><span class="s1">&#39;The Dark Knight Rises&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; [&quot;th&quot;, &quot;the&quot;, &quot;da&quot;, &quot;dar&quot;, &quot;dark&quot;, &quot;kn&quot;, &quot;kni&quot;, &quot;knig&quot;, &quot;knigh&quot;, &quot;knight&quot;, &quot;ri&quot;, &quot;ris&quot;, &quot;rise&quot;, &quot;rises&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>We need to generate those prefixes for every movie we want to use in our search
autocompletion and so I use a minimum prefix length of two characters here,
because using one character prefixes is a lot of overhead for search completion
where most people are going to type in more than one character.</p>

<p>(Of course it&#8217;s entirely possible to not only use prefixes, but use every range
of characters from any position in the word. Instead of using <em>fi, fis, fish</em>
for <em>Fish</em>, we could use <em>fi, fis, fish, is, ish, sh</em>. But people are more
likely to type the beginning of a word, I guess.)</p>

<h2>Save those prefixes to sorted sets!</h2>

<p>Redis uses <a href="http://redis.io/topics/data-types#sorted-sets" title="Sorted
Sets">sorted sets</a> as a list of unique strings that can be ranked by a score. For now, we
will ignore the score and just use this as a set where every entry is unique and
trying to add a new one with the same name won&#8217;t result in a new entry. So let&#8217;s
create a sorted set for every prefix. This set will include the key of the
movies in which the prefix occurs and the pattern for those keys is the one
Soulmate uses: <code>moviesearch:index:$PREFIX</code>.</p>

<p>In order to associate the movie <em>The Dark Knight</em> with its prefixes we need
to do the following for every prefix:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">ZADD</span> <span class="n">moviesearch</span><span class="ss">:index:dar</span> <span class="mi">0</span> <span class="mi">9</span>
</span></code></pre></td></tr></table></div></figure>


<p>As you might have guessed, the prefix here is <em>dar</em>. The next number in this
command is the score the member of this sorted set will have, but as I said,
ignore this for now and keep in mind that the <code>9</code> is the key of our <code>moviesearch:data</code>
hash pointing to the <em>The Dark Knight</em>. So we need to associate all prefixes of
every moviename with its key in the <code>moviesearch:data</code> hash. Written in Ruby a
method doing exactly that would look like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">add_movie</span><span class="p">(</span><span class="n">movie_name</span><span class="p">,</span> <span class="n">data_hash_key</span><span class="p">)</span>
</span><span class='line'>  <span class="n">prefixes</span> <span class="o">=</span> <span class="n">prefixes_for</span><span class="p">(</span><span class="n">movie_name</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">prefixes</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">prefix</span><span class="o">|</span>
</span><span class='line'>    <span class="no">REDIS</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="s2">&quot;moviesearch:index:</span><span class="si">#{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data_hash_key</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&#8217;s pretty simple, isn&#8217;t it? The method takes two arguments: the name of the
movie and the key of the <code>moviesearch:data</code> hash pointing to its data. After
using that method for all the movies we added to our data hash, we have a lot of
sorted sets with its members being the keys for our data hash. That means, after
adding <em>The Dark Knight</em> and <em>The Dark Knight Rises</em> the
<code>moviesearch:index:dark</code> set has two members: <code>9</code> and <code>10</code>. So, what does that
give us? How do we profit from this?</p>

<p>Let&#8217;s imagine a user is visiting our website and using the search form he&#8217;s typing
<em>dar</em> into the input field.</p>

<p>We now get all the entries in <code>moviesearch:index:ki</code>, which are the keys of our
moviesearch:data hash. The sorted set with the key <code>moviesearch:index:dar</code>
contains <code>9</code> and <code>10</code> as members. With those numbers we can now just fetch all
the hash entries with these as key and present them to the user. But
let&#8217;s see how that works.</p>

<h2>Matching more than one word using Redis&#8217; <code>ZINTERSTORE</code></h2>

<p>If we want to get all the entries for <code>moviesearch:index:ki</code> we use the ZRANGE
command provided by Redis:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">ZRANGE</span> <span class="n">moviesearch</span><span class="ss">:index:dar</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Starting from the first element (<code>0</code> since Redis starts indexing with 0) and going
to the last (<code>-1</code>) we get the hash keys for movies whose names contain the prefix &#8216;dar&#8217;:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>redis-cli ZRANGE moviesearch:index:dar 0 -1
</span><span class='line'>1<span class="o">)</span> <span class="s2">&quot;9&quot;</span>
</span><span class='line'>2<span class="o">)</span> <span class="s2">&quot;10&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>And now, let&#8217;s fetch all the entries from our <code>moviesearch:data</code> with those
keys:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>redis-cli HMGET moviesearch:data 9 10
</span><span class='line'>1<span class="o">)</span> <span class="s2">&quot;{\&quot;name\&quot;:\&quot;The Dark Knight Rises\&quot;,\&quot;year\&quot;:2008}&quot;</span>
</span><span class='line'>2<span class="o">)</span> <span class="s2">&quot;{\&quot;name\&quot;:\&quot;The Dark Knight\&quot;,\&quot;year\&quot;:2008}&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Instead of using <code>HGET</code> we use <code>HMGET</code> to fetch multiple hash entries. That&#8217;s
quite neat! Now we have all the movies containing a word that starts with
&#8216;dar&#8217;. And we could present those to the user, who is typing and waiting for
suggestions. Let&#8217;s go one step further though:</p>

<p>Let&#8217;s suppose a user has typed <em>ki bi</em> into our search form. We now want to
present him <em>Kill Bill, </em>Kill Bill 2<em>, </em>Kilts for Bill<em> as suggestions, but not
</em>Killer Elite<em> and not </em>King Kong*. That means we need to find a movie
containing both those prefixes in its name and not only one of them. And this is
exactly where Redis&#8217; <a href="http://redis.io/commands/zinterstore" title="Redis ZINTERSTORE command">ZINTERSTORE</a>
comes out to play.</p>

<p><code>ZINTERSTORE</code> creates a new sorted with a given key containing all the members
occuring in the sets passed to it. Let&#8217;s use it to create a temporary set
containing the hash keys of the movies having &#8216;ki bi&#8217; in their names:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>redis-cli ZINTERSTORE moviesearch:index:ki|bi 2 moviesearch:index:ki moviesearch:index:bi
</span></code></pre></td></tr></table></div></figure>


<p>What happens here? <code>ZINTERSTORE</code> looks up which members are in both
<code>moviesearch:index:ki</code> and <code>moviesearch:index:bi</code> and creates a new sorted set
with the key <code>moviesearch:index:ki|bi</code> containing those members. The pattern for
this key is also from Soulmate: dig through the code as there are lots of great
ideas! Now we can use the <code>ZRANGE</code> command again and see which movies contain
those prefixes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>redis-cli ZRANGE <span class="s1">&#39;moviesearch:index:ki|bi&#39;</span>
</span><span class='line'>1<span class="o">)</span> <span class="s2">&quot;1&quot;</span>
</span><span class='line'>2<span class="o">)</span> <span class="s2">&quot;4&quot;</span>
</span><span class='line'>3<span class="o">)</span> <span class="s2">&quot;5&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>And those are exactly the keys pointing to <em>Kill Bill</em>, <em>Kill Bill 2</em> and <em>Kilts
For Bill</em> in the <code>moviesearch:data</code> hash! Great! All we have to do now is use
<code>HMGET</code> to get the data for those keys from the hash and present them to the
user.</p>

<h2>Score &amp; Popularity</h2>

<p>Until now we ignored the score of our sorted sets. But let&#8217;s say all our users
are looking up <em>Kill Bill</em> by typing in <em>Ki Bi</em> and hitting enter. Let&#8217;s also
assume there are a lot more users looking up <em>Kill Bill</em> than there are people
interested in <em>Kindergarten Cop</em> (as weird as this assumption may sound, bear
with me here). Remember when we associated the movies with the prefixes? We did
this, using <code>0</code> as the score:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ZADD moviesearch:index:ki 0 1
</span></code></pre></td></tr></table></div></figure>


<p>Now, everytime a person looks up <em>Kill Bill</em> instead of <em>Kindergarten Cop</em> we
can increment the score of the <code>1</code> entry (pointing to <em>Kill Bill</em>) in the
<code>moviesearch:index:ki</code> set (and all the other sets containing <code>1</code>) using
<a href="http://redis.io/commands/zincrby" title="Redis ZINCRBY command">ZINCRBY</a>. <code>ZINCRBY</code>
increments the score of a given member in a given set by a given value. In order
to sort our results by popularity we could increment the score of a given movie
everytime a user looks that movie up. A simple method for doing this would
probably look like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">incr_score_for</span><span class="p">(</span><span class="n">movie_name</span><span class="p">,</span> <span class="n">data_hash_key</span><span class="p">)</span>
</span><span class='line'>  <span class="n">prefixes</span>    <span class="o">=</span> <span class="n">prefixes_for</span><span class="p">(</span><span class="n">movie_name</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">prefixes</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">prefix</span><span class="o">|</span>
</span><span class='line'>    <span class="no">REDIS</span><span class="o">.</span><span class="n">zincrby</span><span class="p">(</span><span class="n">index_key_for</span><span class="p">(</span><span class="n">prefix</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data_hash_key</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>We take every prefix occuring in the movie name and increment the score of the
member pointing to the movies data in the <code>moviesearch:data</code> hash.</p>

<p>Now, before thinking about scores of set members we used <code>ZRANGE</code> to get the
members of a given set. Working with scores now, the next time when we try to
match a movie with the given prefixes we use
<a href="http://redis.io/commands/zrevrange" title="Redis ZREVRANGE command">ZREVRANGE</a> to
return the matching hash keys ordered by their respective score. The following
should then give us <em>Kill Bill</em> at the top after we incremented the score for
this movie every time a user looks it up.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">ZREVRANGE</span>  <span class="n">moviesearch</span><span class="ss">:index:ki</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Using <code>ZREVRANGE</code>, <code>ZUNIONSTORE</code> and <code>HMGET</code> combined we can write a Ruby method
to look up movies matching the passed prefixes and order them by score:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">find_by_prefixes</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)</span>
</span><span class='line'>  <span class="n">intersection_key</span> <span class="o">=</span> <span class="n">index_key_for</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)</span>
</span><span class='line'>  <span class="n">index_keys</span>       <span class="o">=</span> <span class="n">prefixes</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">prefix</span><span class="o">|</span> <span class="n">index_key_for</span><span class="p">(</span><span class="n">prefix</span><span class="p">)}</span>
</span><span class='line'>
</span><span class='line'>  <span class="no">REDIS</span><span class="o">.</span><span class="n">zinterstore</span><span class="p">(</span><span class="n">intersection_key</span><span class="p">,</span> <span class="n">index_keys</span><span class="p">)</span>
</span><span class='line'>  <span class="no">REDIS</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">intersection_key</span><span class="p">,</span> <span class="mi">7200</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">data_hash_keys</span>  <span class="o">=</span> <span class="no">REDIS</span><span class="o">.</span><span class="n">zrevrange</span><span class="p">(</span><span class="n">intersection_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>  <span class="n">matching_movies</span> <span class="o">=</span> <span class="no">REDIS</span><span class="o">.</span><span class="n">hmget</span><span class="p">(</span><span class="n">data_key</span><span class="p">,</span> <span class="o">*</span><span class="n">data_hash_keys</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">matching_movies</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">movie</span><span class="o">|</span> <span class="no">JSON</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">symbolize_names</span><span class="p">:</span> <span class="kp">true</span><span class="p">)}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>This method takes an array of prefixes as argument, creating the index keys for
them, then it creates a temporary sorted set using <code>ZINTERSTORE</code> (<code>EXPIRE</code> tells Redis to delete a
given key after the specified time in seconds) containing the data hash keys
pointing to the movies. After that <code>ZREVRANGE</code> gets us all the members of this
set ordered by their score and finally <code>HMGET</code> is used to get the data for all
the matching keys from the <code>moviesearch:data</code> hash. There are a couple of helper
methods involved, but it should still be pretty clear what happens. If not, look
at the code of the whole <code>MovieMatcher</code> class I use in Anygood
<a href="https://gist.github.com/2900740" title="Anygood MovieMatcher class">here</a>.</p>

<p>So everything combined we use Redis hashes to save our data, sorted sets for
every prefix whose members point at our movies in the hash and in order to find
movies containing multiple prefixes we use <code>ZINTERSTORE</code> as a cache to point us
to the movies containing both. And now we&#8217;ve got search autocompletion
presenting ordered results to the user matching multiple phrases!</p>

<p>If you want to dig deeper, please read through the source code of Soulmate and
study those two articles mentioned in the first paragraph. They both do a great
job at explaining what exactly is going on here and why to use sorted sets and
the other data types as we do.</p>

<p>And if you&#8217;re not <a href="http://www.twitter.com/herrbrocken" title="Follow me!">following me on Twitter</a>
you&#8217;re missing out!</p>
]]></content>
  </entry>
  
</feed>
